"""
Module that wraps the top level API for the AFK Arena Roster Screenshot and
Hero processing

Calling detect_features assumes that the image processing environment has been
initialized and will parse apart an image and feed it into the various models
needed to detect AFK Arena Hero Features
"""
from typing import TYPE_CHECKING

import cv2
import numpy as np
from pandas import DataFrame

import image_processing.globals as GV
from image_processing.database.configs.ascension_constants import (
    ABBREVIATED_ASCENSION_TYPES)
from image_processing.utils.color_helper import MplColorHelper
from image_processing.afk.hero.process_heroes import (
    get_heroes, get_hero_contours)
from image_processing.processing.image_data import SegmentResult
from image_processing.models.model_attributes import (
    ASCENSION_STAR_LABELS, FI_LABELS, ModelResult, SI_LABELS)
from image_processing.afk.roster.matrix import Matrix
from image_processing.afk.hero.hero_data import (
    DetectedHeroData, RosterData, HeroMatchJson)
from image_processing.afk.roster.dimensions_object import DoubleCoordinates
from image_processing.database.engravings_database import EngravingData
from image_processing.utils.verbose_print import print_verbose

if TYPE_CHECKING:
    from image_processing.models.yolov5.models.common import Detections


FONT = cv2.FONT_HERSHEY_SIMPLEX
TEXT_COLOR = MplColorHelper().get_rgb("red")
THICKNESS = 2


def detect_features(roster_image: np.ndarray):
    """
    Detect AFK Arena heroes from a roster screenshot and for each hero detect
        "FI", "SI", "Ascension", and "hero Name"
    Args:
        roster_image: image to run segmentation and detection on
    """
    blur_args = {"hsv_range": GV.HERO_ROSTER_HSV}
    # Run HSV segmentation on hero roster to get hero
    GV.GLOBAL_TIMER.start('Roster Segmentation', reset=True)

    segment_dict, segment_matrix = get_heroes(roster_image, blur_args)
    GV.GLOBAL_TIMER.stop()

    GV.GLOBAL_TIMER.start("Image Recognition")
    detected_hero_data: list[DetectedHeroData] = []
    for _pseudo_segment_name, segment_info in segment_dict.items():
        # display_image(segment_info.image, display=True)

        GV.GLOBAL_TIMER.start("Hero Detection")
        hero_matches = GV.IMAGE_DB.search(segment_info)
        GV.GLOBAL_TIMER.stop()

        best_hero_match = hero_matches.best()
        print_verbose(f"Detected hero: {best_hero_match}", verbose_level=1)
        # Get the hero information about the detected hero
        best_match_info = GV.IMAGE_DB.hero_lookup[best_hero_match.name].first()
        hero_prediction_result = HeroMatchJson(best_match_info.name,
                                               best_hero_match.match_count,
                                               best_hero_match.total_matches)

        GV.GLOBAL_TIMER.start("Attribute Detection")
        detected_hero_result = detect_attributes(hero_prediction_result,
                                                 segment_info)
        GV.GLOBAL_TIMER.stop()
        detected_hero_data.append(detected_hero_result)

       # When debugging Draw hero info on image
        if GV.verbosity(2):
            label_hero_feature(roster_image, segment_info,
                               detected_hero_result, segment_matrix)

    GV.GLOBAL_TIMER.display()

    return RosterData(detected_hero_data, segment_matrix)


def label_hero_feature(roster_image: np.ndarray,
                       segment_info: SegmentResult,
                       detected_hero_result: DetectedHeroData,
                       hero_matrix: Matrix):
    """
    Write hero data such as FI/SI/Stars onto the roster image those attributes
        were derived from

    Args:
        roster_image (np.ndarray): roster of heroes
        segment_info (processing.SegmentResult): object with info describing the
            location of 'detected_hero_result' in DetectedHeroData
        detected_hero_result (DetectedHeroData): data about a hero in the
            'roster_image' generated by 'detect_attributes'
        hero_matrix (matrix.matrix): matrix of hero data in the same horizontal
            and vertical order they were detected in
    """

    font_scale = 0.5 * (hero_matrix.get_avg_width()/100)

    result = str(detected_hero_result)

    hero_pixel_coordinate = (segment_info.segment_location.dimensions.x,
                             segment_info.segment_location.dimensions.y)
    text_size = cv2.getTextSize(result, FONT, font_scale, THICKNESS)
    height = text_size[0][1]
    bottom_left_coordinate = (hero_pixel_coordinate[0],
                              hero_pixel_coordinate[1] + round(5 * height))

    cv2.putText(roster_image, result, bottom_left_coordinate, FONT,
                abs(font_scale), TEXT_COLOR, THICKNESS, cv2.LINE_AA)


def detect_furniture(detected_furniture: DataFrame):
    """_summary_

    Args:
        detected_furniture (DataFrame): _description_

    Returns:
        _type_: _description_
    """

    furniture_result = ModelResult("0", 0)
    GV.GLOBAL_TIMER.start("Detect Furniture")
    if len(detected_furniture) > 0:
        best_furniture_match = detected_furniture.sort_values(
            "confidence").iloc[0]
        best_furniture_label = FI_LABELS[best_furniture_match["class"]]

        if best_furniture_match["confidence"] >= 0.85:
            furniture_result = ModelResult(
                best_furniture_label, best_furniture_match["confidence"])
    GV.GLOBAL_TIMER.stop()
    return furniture_result


def detect_signature_item(detected_signature_items: DataFrame):
    """_summary_

    Args:
        detected_signature_items (DataFrame): _description_

    Returns:
        _type_: _description_
    """
    signature_item_result = ModelResult("0", 0)
    GV.GLOBAL_TIMER.start("Detect SI")
    if len(detected_signature_items) > 0:
        best_signature_item_match = detected_signature_items.sort_values(
            "confidence", ascending=False).iloc[0]
        best_signature_item_label = (
            SI_LABELS[best_signature_item_match["class"]])

        if best_signature_item_match["confidence"] >= 0.85:
            signature_item_result = ModelResult(
                best_signature_item_label,
                best_signature_item_match["confidence"])
    GV.GLOBAL_TIMER.stop()
    return signature_item_result


def detect_ascension(detected_ascension_stars: DataFrame,
                     image: np.ndarray):
    """_summary_

    Args:
        detected_ascension_stars (DataFrame): _description_
        segment_info (processing.SegmentResult): object with info describing the
            location of 'detected_hero_result' in DetectedHeroData
    Returns:
        _type_: _description_
    """
    ascension_result = ModelResult("E", 0)
    best_match_coordinates = None
    GV.GLOBAL_TIMER.start("Detect Ascension(All)")
    if len(detected_ascension_stars) > 0:
        best_ascension_stars_match = detected_ascension_stars.sort_values(
            "confidence", ascending=False).iloc[0]
        best_match_coordinates = DoubleCoordinates(
            best_ascension_stars_match["xmin"],
            best_ascension_stars_match["xmax"],
            best_ascension_stars_match["ymin"],
            best_ascension_stars_match["ymax"])

        best_ascension_stars_label = ASCENSION_STAR_LABELS[
            best_ascension_stars_match["class"]]

        ascension_result = ModelResult(
            best_ascension_stars_label,
            best_ascension_stars_match["confidence"])
    # If ascension score for ascended hero with stars is below 0.75
    #   confidence, detect border results for E - A ascension levels
    if ascension_result.score < 0.75:
        GV.GLOBAL_TIMER.start("Detect Ascension(E-A)")
        # pylint: disable=not-callable
        raw_ascension_model_results: "Detections" = GV.ASCENSION_BORDER_MODEL(
            [image], size=GV.MODEL_IMAGE_SIZE)

        labeled_ascension_model_results: DataFrame = \
            raw_ascension_model_results.pandas().xyxy[0]
        detected_ascension = labeled_ascension_model_results

        if len(detected_ascension) > 0:

            best_ascension_match = detected_ascension.sort_values(
                "confidence", ascending=False).iloc[0]
            best_ascension_label = (
                ABBREVIATED_ASCENSION_TYPES[best_ascension_match["class"]])

            ascension_result = ModelResult(best_ascension_label,
                                           best_ascension_match["confidence"])

            print_verbose(f"Ascension Results: {ascension_result}")
        GV.GLOBAL_TIMER.stop()
    GV.GLOBAL_TIMER.stop()

    return ascension_result, best_match_coordinates


def detect_engraving(ascension_result: ModelResult,
                     image: np.ndarray,
                     star_coordinates: DoubleCoordinates):
    """_summary_

    Args:
        ascension_result (ModelResult): _description_
        image (np.ndarray): image in RGB format
        star_coordinates (DoubleCoordinates): _description_

    Returns:
        _type_: _description_
    """

    engraving_result = ModelResult("0", 0)
    # pylint: disable=unsupported-membership-test
    if ascension_result.label in ASCENSION_STAR_LABELS.inverse:
        temp_image = image[star_coordinates.y1:star_coordinates.y2,
                           star_coordinates.x1:star_coordinates.x2]
        contour_wrapper = get_hero_contours(
            temp_image, hsv_range=GV.ASCENSION_STAR_HSV)
        contour_list = contour_wrapper.filter_contours()

        # When no contours are return from filter_contours we can take the
        #   average color from the largest contour that was detected
        if len(contour_list) == 0:
            contour_list = contour_wrapper.largest()

        engraved_star_mask = np.zeros(temp_image.shape[:2], np.uint8)
        for contour_dimension_object in contour_list:
            cv2.drawContours(
                engraved_star_mask,
                [contour_dimension_object.raw_contour],
                -1, 255, -1)
        mean = cv2.mean(temp_image, mask=engraved_star_mask)
        engraving_results = GV.ENGRAVING_DB.search(
            EngravingData(mean[0], mean[1], mean[2]))
        print_verbose(f"Engraving Result: {engraving_results}")
        engraving_result = engraving_results[0]
    return engraving_result


def detect_attributes(name_result: HeroMatchJson, segment_info: SegmentResult,
                      ):
    """
    Detect hero features such as FI, SI, Stars and ascension level using'
        custom trained yolov5 and detectron2 image recognition models

    Args:
        hero_image_info (HeroImage): A wrapper around an image detected from
            the Flann image database that includes the image itself, the image
            name and the location the image was loaded from
        segment_info (processing.SegmentResult): object with info describing the
            location of 'detected_hero_result' in DetectedHeroData
        name_result (ModelResult): A model result containing the detected heroes
            name and confidence/score of the hero prediction
    Returns:
        [type]: [description]
    """

    resized_image = cv2.resize(segment_info.image,
                               (GV.MODEL_IMAGE_SIZE, GV.MODEL_IMAGE_SIZE))
    rgb_image = cv2.cvtColor(resized_image, cv2.COLOR_BGR2RGB)

    # pylint: disable=not-callable
    GV.GLOBAL_TIMER.start("Attribute Model Results")
    raw_model_results: "Detections" = GV.FI_SI_STAR_MODEL(
        [rgb_image], size=GV.MODEL_IMAGE_SIZE)
    GV.GLOBAL_TIMER.stop()

    labeled_model_results: DataFrame = raw_model_results.pandas().xyxy[0]

    detected_furniture: DataFrame = labeled_model_results.loc[
        labeled_model_results['class'].isin(FI_LABELS.keys())]
    detected_ascension_stars: DataFrame = labeled_model_results.loc[
        labeled_model_results['class'].isin(ASCENSION_STAR_LABELS.keys())]
    detected_signature_items: DataFrame = labeled_model_results.loc[
        labeled_model_results['class'].isin(SI_LABELS.keys())]

    furniture_result = detect_furniture(detected_furniture)
    ascension_result, star_coordinates = detect_ascension(
        detected_ascension_stars, rgb_image)
    signature_item_result = detect_signature_item(detected_signature_items)
    engraving_result = detect_engraving(
        ascension_result, rgb_image, star_coordinates)

    hero_data = DetectedHeroData(name_result, signature_item_result,
                                 furniture_result, ascension_result,
                                 engraving_result, rgb_image)
    return hero_data
